# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGreenlandDialog
                                 A QGIS plugin
 Download QGreenland dataset
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-08-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Matteo Ghetta (Faunalia)
        email                : matteo.ghetta@faunalia.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
import requests

from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtWidgets import (
    QTreeWidgetItem,
    QTreeWidget,
    QFileDialog,
    QSizePolicy,
    QGridLayout
)
from qgis.PyQt.QtGui import QIcon, QStandardItemModel
from qgis.PyQt.Qt import Qt

from qgis.core import (
    QgsApplication,
    Qgis
)

from qgis.gui import (
    QgsMessageBar
)

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgreenland_dialog_base.ui'))


class QGreenlandDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QGreenlandDialog, self).__init__(parent)
        self.setupUi(self)

        # create instance of QgsMessageBar and add the widget to the layout
        self.bar = QgsMessageBar()
        self.layout().addWidget(self.bar, 0, 0, -1, 3, Qt.AlignTop)
        # call whenever needed with
        # self.bar.pushMessage(self.tr("Message"), "", level=Qgis.Info, duration=3)


        # connect the Next and Prev buttons to the methods that change the page
        self.next_button.clicked.connect(self._next)
        self.prev_button.clicked.connect(self._prev)

        # add to the server_list combobox the URLS
        self.server_list_combo.addItem(self.tr('NSIDC: https://nsidc.org/qgreenland'), 'https://nsidc.org/qgreenland')
        self.server_list_combo.addItem(self.tr('PGC: https://example.com/qgreenland'), 'https://example.com/qgreenland')

        # pressing (not only selecting or checking) on an item fills the information
        self.treeWidget.itemPressed.connect(self.display_information)

        # TODO: shoukld check and uncheck all the items depending on the parent
        self.treeWidget.itemClicked.connect(self.check_uncheck)

        # when the text changes connect to the filter function
        self.search_box.textChanged.connect(self.set_filter_string)

        # connect to the methods that creates the QGreenland folder if not exists
        self._user_profile_folder()
        
        # fill the treeWidget with the json information
        self._fill_tree()

        # connect the Download button with the download_data method
        self.download_button.clicked.connect(self.download_data)

        self.browse_button.clicked.connect(self.browse_folder)

        self.download_button.setEnabled(False)


    def _user_profile_folder(self):
        """
        check if the user profile folder QGreenland exists and read the local
        file with all the downloaded layer information to match the data version
        """

        self.profile_path = QgsApplication.qgisSettingsDirPath()
        self.qgreenland_path = os.path.join(self.profile_path, 'QGreenland')

        # if not os.path.exists(self.qgreenland_path):
        try:
            os.mkdir(self.qgreenland_path)
        except FileExistsError as e:
            pass

    def _next(self):
        """
        go to the next page of the stacked widget
        """

        # get the current index of the stackedWidget
        i = self.stackedWidget.currentIndex()

        # go to the next page
        self.stackedWidget.setCurrentIndex(i+1)

        # call the method to fill the treeWidget with all the data
        self._fill_tree()

    def _prev(self):
        """
        go to the previous page of the stacked widget
        """

        # get the current index of the stackedWidget
        i = self.stackedWidget.currentIndex()

        # go to the previous page
        self.stackedWidget.setCurrentIndex(i-1)

    def _download(self):
        """
        go to the download page of the stacked widget
        """

        # get the current index of the stackedWidget
        i = self.stackedWidget.currentIndex()

        # go to the download page
        self.stackedWidget.setCurrentIndex(i+1)

    def _fill_tree(self):
        """
        Fill hte treeWidget with the json file creating QTreeWidgetItem items
        and parents

        Sets the items as checkable and unchecked by default
        """

        # clear the treeWidget
        self.treeWidget.clear()

        # call the read_json function that reads the eventual existing json
        # file with the downloaded information of the files
        if os.path.exists(os.path.join(self.qgreenland_path, 'layers.json')):
            downloaded_layers = self.read_json(os.path.join(self.qgreenland_path, 'layers.json'))
        
        # temporary read the manifest local json file
        # make it persistent as self.data
        # json_file = os.path.join(os.path.dirname(__file__), 'manifest.json')
        # with open(json_file, 'r') as f:
        #     self.data = json.load(f)

        # load the manifest data from the remote url
        # make it persistent as self.data
        url = 'http://localhost:8080/manifest.json'
        json_file = requests.get(url)
        self.data = json.loads(json_file.text)
        
        # empty list of all the hierarchies
        hierarchy = []
        # loop and grab all the hierarchies of all layers
        for layer in self.data['layers']:
            for h in layer['hierarchy']:
                hierarchy.append(h)
        
        # use set to avoid duplicates
        hierarchy = list(set(hierarchy))

        # loop into the hierarchies and fill the QTreeWidget with them
        for h in hierarchy:

            item = QTreeWidgetItem([h])
            item.setCheckState(0, Qt.Unchecked) # first columun, checkable, checked=0
            self.treeWidget.addTopLevelItem(item)

            # loop in all the layers of the json
            for layer in self.data['layers']:

                # check the hierarchy of the single layer to correct inser it as a child
                if h in layer['hierarchy']:
                    
                    # create the child (checkable)
                    child = QTreeWidgetItem([layer['title']])
                    # set the custom data for the item as the unique id of each layer
                    child.setData(0, Qt.UserRole, layer['id'])
                    # to add an icon to the single item
                    # child.setIcon(0, QIcon(os.path.join(os.path.dirname(__file__), 'qgreenland-icon.png')))
                    child.setCheckState(0, Qt.Unchecked)

                    # add the icons depending on the checksum
                    # only if the json file in the profile folder exists
                    try:
                        for static_layer in downloaded_layers:
                            for i in static_layer['assets']:
                                # check if the layer of the manifest is in the static json file of the profile folder
                                if layer['id'] in static_layer['id']:
                                    # get the data type - the layer
                                    if i['type'] == 'data':
                                        # if the checksum is the same - we have the most recent layer downloaded
                                        if layer['assets'][0]['checksum'] == i['checksum']:
                                            child.setIcon(0, QIcon(os.path.join(os.path.dirname(__file__), 'icons','uptodate.png')))
                                            child.setToolTip(0, self.tr("You already have the most recent data downloaded"))
                                        # if the checksum is not the same - warn the user with the specified icon
                                        elif layer['assets'][0]['checksum'] != i['checksum']:
                                            child.setIcon(0, QIcon(os.path.join(os.path.dirname(__file__), 'icons','outdate.png')))
                                            child.setToolTip(0, self.tr("A more recent version of the file is available"))
                    except:
                        pass
        
                    # add the child to the parent item
                    item.addChild(child)

        # sort the tree by the first column and A->Z (should be done at the end to avoid performance issues)
        self.treeWidget.sortByColumn(0, 0)


    def display_information(self):
        """
        Fill the text edit with the information taken from the manifest file
        """

        # get the current item of the treeWidget
        item = self.treeWidget.currentItem()

        # only children have parents :)
        if item.parent() is not None:

            # loop into the manifest file (self.data = dictionary)
            for layer in self.data['layers']:

                # get the correspondence between the clicked layer in the treeWidget and the title in the dictionary
                if layer['title'] == item.text(0):

                    text = f'''
                    <h2>Name</h2>
                    {layer['title']}
                    <h2>Description</h2>
                    {layer['description']}
                    <h2>Details</h2>
                    {layer['layer_details']}
                    '''

                    self.summary_text.setHtml(text)

        # just temporary call the method to get the checked items
        self.get_checked_items()
    

    def get_checked_items(self):
        """
        get a list of all the checked items
        to get the unique id for each layer: item.data(0, Qt.UserRole)
        TODO: right now only if the item IS SELECTED the system works, not working
        if the single checkbox is checked 
        """

        # get a set to have unique and not repeated data that belongs to different categories
        self.checked_items = set()

        for item in self.treeWidget.findItems("", Qt.MatchContains | Qt.MatchRecursive):
            if item.checkState(0) == Qt.Checked:
                # add to the set the Qt.UserRole (AKA label) defined above
                self.checked_items.add(item.data(0, Qt.UserRole))
        
    
    def write_json(self, item_list):
        """
        TODO: handle appending of layers to the file
        method to call when downloading the selected files. Writes a json file
        in the QGreenland folder within the QGIS profile one with the layer
        information that we need. The json is a list of single layers, where each
        layer has the following structure:

        {
            "id": "nunagis_polar_bears",
            "assets": [
                {
                    "file": "nunagis_bears.gpkg",
                    "type": "data",
                    "checksum": "ff68078f6ef14df085c2d84e2eff573e",
                    "size_bytes": 184320
                },
                {
                    "file": "nunagis_bears.qml",
                    "type": "style",
                    "checksum": "ksc14ec6110fa820ca6b65f5aec85911",
                    "size_bytes": 1521
                },
                {
                    "file": "nunagis_bears.xml",
                    "type": "ancillary",
                    "checksum": "po91b6919b9a77a9fe98a8e574214abf",
                    "size_bytes": 2091
                }
            ]
        },

        We will use the checksum parameter to check if the layer downloaded is
        outdated (has a different checksum) and warn the user.

        :param item_list: set of checked layers in the treeWidget
        :type item_list: set
        """

        # empty list that will be filled
        downloaded_layers = []

        # check if a json file already exists adn overwrite the existing list
        if os.path.exists(os.path.join(self.qgreenland_path, 'layers.json')):
            downloaded_layers = self.read_json(os.path.join(self.qgreenland_path, 'layers.json'))

        # get a set of the existing layer id of the json file to avoid appending the same value
        layers_in_json = set()
        for lay in downloaded_layers:
            layers_in_json.add(lay['id'])


        # loop in the item list and check if the id of the selected layer is already in the file
        for item in item_list:
            # temporary dictionary that will be filled with the layer information
            d = {}
            
            for layer in self.data['layers']:
                # check if the if of the whole layer list is both a checked item
                # and is not in the set
                if layer['id'] == item and layer['id'] not in layers_in_json:

                    # add to the dictionray the information needed
                    d['id'] = layer['id']
                    d['assets'] = layer['assets']

                    # append to the list the dictionary for every item
                    downloaded_layers.append(d)

        # write the final json file with the updated list
        with open(os.path.join(self.qgreenland_path, 'layers.json'), 'w') as json_file:
            json.dump(downloaded_layers, json_file, indent=4)


    def read_json(self, json_path):
        """
        given a path of the json file, read and return it as a list

        :param json_path: path of the json file
        :type json_path: str
        :return: dump of the json file
        :rtype: list
        """

        with open(json_path, 'r') as json_file:
            downloaded_layers = json.load(json_file)
        
        return downloaded_layers

        

    def set_filter_string(self):

        filter_string = self.search_box.text()

        for item in self.treeWidget.findItems(filter_string, Qt.MatchContains | Qt.MatchRecursive, 0):
            if item.parent():
                item.parent().removeChild(item)
        
        if not filter_string:
            self._fill_tree()


    def check_uncheck(self):

        item = self.treeWidget.currentItem()
        if item and not item.parent():
            # not recursive so we have only main categories and not single children
            if item.checkState(0) == Qt.Checked:
                for num in range(item.childCount()):
                    child = item.child(num)
                    child.setCheckState(0, Qt.Checked)
            # if the category is unchecked, uncheck also the children
            elif item.checkState(0) == Qt.Unchecked:
                for num in range(item.childCount()):
                    child = item.child(num)
                    child.setCheckState(0, Qt.Unchecked)
        
        
    def download_data(self):
        """
        method that downloads all the selected data (AKA checked items)
        """

        # that's the list (or set) of the data to download
        if self.checked_items:
            self.write_json(self.checked_items)
        
        for layer in self.data['layers']:
            
            for ii in self.checked_items:

                if layer['id'] == ii:

                    print(layer['assets'][0]['file'])
        

    def browse_folder(self):
        """
        open a QDialog to choose the folder where to save the data
        """

        self.saving_folder = QFileDialog.getExistingDirectory(
            None,
            self.tr("Choose a directory to save the data"),
            "",
            QFileDialog.ShowDirsOnly
        )

        if not self.saving_folder:
            self.bar.pushMessage(self.tr("You have to select a folder where to save the data"), "", level=Qgis.Critical, duration=-1)
            return
        else:
            self.download_button.setEnabled(True)
            print(self.saving_folder)

        self.folder_path.setText(self.saving_folder)